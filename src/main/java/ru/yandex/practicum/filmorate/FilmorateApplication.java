package ru.yandex.practicum.filmorate;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class FilmorateApplication {

	public static void main(String[] args) {
		SpringApplication.run(FilmorateApplication.class, args);
	}
	/*
	Семён, привет!
	По поводу абстрактного класса... Я пробовал сделать так, как ты говоришь. Только есть нюанс именно с ID
	абстрактного объекта, который я использую при update. Я получаю ID объекта через getter. А у абстрактной
	сущности нет ни сеттеров, ни геттеров. Но сейчас я столкнулся с тем, что у двух хранилищ методы-то может и
	одинаковые, но из-за переноса обработки из контроллера в хранилище я теперь имею разные проверки объектов
	(допустим, email у фильма нет, а у фильма нет логина). Плюс я делаю логирование, где указываю непосредственно
	тот объект, который берётся в обработку, например "Фильм не может быть выпущен раньше дня рождения кино!". Т.е.
	можно, конечно, объединить классы, но реализацию методов всё равно придётся делать через @Override. Тогда смысл в
	этом абстрактном классе отпадает, как мне кажется.

	Касаемо рейтинга фильма - поле с лайками есть. Если имеешь в виду количество лайков, то логично, наверное, его
	добавить, чтобы каждый раз не считывать размер Set'а, который у нас отвечает за лайки. Добавил его) Возможно, в
	будущем проще будет отдавать сразу готовый размер, нежели брать размер Set'а - лишнее действие.
	На всякий случай добавил количество друзей у пользователей - также отдельным полем.

	По поводу id и проверки на null. Я добавил @NotNull для этого поля у пользователя и у фильма. Но зачем нам
	делать проверку примитива long на null? Он же по умолчанию будет 0. А через filmStorage/userStorage ему будет
	присвоен соответствующий id. Просто именно null там невозможен, насколько я понимаю...

	По create, update и т.д. - добавил проверку получаемого объекта на null. Т.к. в случае получения пустого объекта
	получим всеми "любимое" NPE. Я до этого её не делал, так как в аргументах метода была аннотация @Valid. Но, в
	принципе, если вдруг эту аннотацию забыть или использовать методы где-то ещё, возникнет NPE. Да и в принципе такие
	моменты лучше обрабатывать по умолчанию, думаю.

	По ветвлениям в контроллере принял. Единственное, оставил проверку на корректность ID в контроллере. Мне кажется,
	всё же имеет смысл проверить число сразу, прежде чем вызывать какие-либо другие методы. Так мы проверили, если
	данные некорректны - сразу выбросили исключение и продолжили работу. Да и в целом, если менять сигнатуру методов на
	обработку Optional, будет не очень, мне кажется. В том плане, что в самом интерфейсе сигнатура любого метода
	подразумевает максимальный "охват", т.е. чем проще будет, тем лучше. Да и в целом, проверка идёт именно пути
	запроса, что непосредственно относится к контроллеру. Думаю, будет корректно оставить обработку именно этого
	момента в контроллере. Остальное вынес непосредственно в вызываемые методы в сервисах и в хранилищах.

	Там, где работаем непосредственно с принимаемым объектом, добавил проверки на null.

	По обработке исключений. В логирование добавил коды состояния HTTP с их описанием (чтобы было проще понять, в чём
	именно кроется ошибка).
	Для самих исключений формировал ответ на запрос через аннотацию @ResponseStatus:
	BAD_REQUEST - 400, NOT_FOUND - 404, INTERNAL_SERVER_ERROR - 500. Т.е. коды из ТЗ мной были применены.
	 */
}
